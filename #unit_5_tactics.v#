Add LoadPath "$COQ_PROOFS" as Path.
Load unit_3_001_structured_data.

Theorem silly1 : forall (n m o p : nat),
     n = m ->
     [n;o] = [n;p] ->
     [n;o] = [m;p].
Proof.
  intros n m o p eq1 eq2.
  rewrite <- eq1.
  rewrite eq2.
  reflexivity.
Qed.

Theorem silly1' : forall (n m o p : nat),
     n = m ->
     [n;o] = [n;p] ->
     [n;o] = [m;p].
Proof.
  intros n m o p eq1 eq2.
  rewrite <- eq1.
  apply eq2.
Qed.

Theorem silly2 : forall (n m o p : nat),
     n = m ->
     (forall (q r : nat), q = r -> [q;o] = [r;p]) ->
     [n;o] = [m;p].
Proof.
<<<<<<< HEAD
  intros n m o p eq1 eq2.
  apply eq2. apply eq1. Qed.
=======
  intros n m o p eq1 eq2. 
  apply eq2. apply eq1. Qed.

Definition oddb (X: nat) := negb (evenb X).

Theorem silly_ex :
     (forall n, evenb n = true -> oddb (S n) = true) ->
     evenb 3 = true ->
     oddb 4 = true.
Proof.
  intros.
  apply H. apply H0.
Qed.

Theorem silly3_firsttry : forall (n : nat),
     true = beq_nat n 5 ->
     beq_nat (S (S n)) 7 = true.
Proof.
  intros n H.
  symmetry.
  simpl.
  apply H.
Qed.


Theorem rev_exercise1 : forall (l l' : natlist),
     l = rev l' ->
     l' = rev l.
Proof.
  assert (forall l: natlist, rev (rev l) = l).
  {
    intros.
    induction l.
    - reflexivity.
    - simpl. rewrite <- rev_involutive. simpl. reflexivity.
  }
  intros.
  induction l'.
  - rewrite H0. simpl. reflexivity.
  - rewrite H0. rewrite H. reflexivity.
Qed.



>>>>>>> b0b6128 (Start Unit 5 - Tactics)
